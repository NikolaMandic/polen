S = statement | statement [{<nl> statement}]
nl = <#'\n'>
statement = (if | while | expression)
if = ('if' | '?') <ws> condition {<nl> statement}
while = ('if' | '?'| (condition '?')) <ws> condition {<nl> statement}
f = 'f'[<'.'> fname]  [<ws> args]  <nl> (statement [{<nl> statement}])
args = ident {<ws> ident }
ws = <#'\s+'>
condition = expression {<ws> expression}
expression = ident | string | number {<ws>} {op {<ws>} expression} | f | memory |
<'('> expression <')'> | '#' wholeRegexp
op = '+'|'-'|'*'|'/'|'=' | bit | '.' | '..' | log
bit = 'on' | 'off' | 'flip' | 'sl' | 'sr' | 'rl' | 'rr' | '>' | '<' |'&'| '|'
log = 'and'|'or'|'||'|'&&'
fname = ident
<ident> = #'\w+'
number = #'[0-9]+'
memory = #'\*[0-9]*x[0-9a-f]*'
string = #'"""\w+"""'
wholeRegexp= wholeRegexp1
wholeRegexp1= wholeRegexp2+ | orregexp
wholeRegexp2 = regexp+ | parenRegexp
regexp = baseRegexp  | regexpStar | regexpQMark
subRegexp = parenRegexp
baseRegexp = char+
orregexp=wholeRegexp1 orm wholeRegexp1
regexpStar = regexpStarEnd
regexpStarEnd = [parenRegexp|baseRegexp] star
regexpStarCont = regexpStarEnd star regexp
regexpQMark = regexpQMarkEnd
regexpQMarkEnd = regexp questionmark
regexpQMarkCont = regexpQMarkEnd regexp
regexpPlus = regexp plus
regexpTrain = regexp+
parenRegexp=<lparen> wholeRegexp1 <rparen>
plus='+'
star='*'
questionmark='?'
orm='|'
lparen = '('
rparen = ')'
char = #'[a-zA-Z0-9]' | '.'
modifier = '?'| '*' | '+'
wholeGramar = 'G' grammarName grammar
grammar = [[token fname]  [grammarName]]+
token  = regexp | fname
grammarName = string